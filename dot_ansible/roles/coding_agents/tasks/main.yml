---
# Coding Agents Installation
# Installs various AI coding assistants and companion tools
# All installations include idempotency checks to avoid slow reinstalls

# === Notification Tools (from claude_deps) ===

# macOS - terminal-notifier
- name: Install terminal-notifier (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  community.general.homebrew:
    name: terminal-notifier
    state: present

# Linux - libnotify-bin (provides notify-send)
- name: Install libnotify-bin (Debian/Ubuntu)
  when: ansible_facts["os_family"] == "Debian"
  become: true
  tags: [sudo]
  ansible.builtin.apt:
    name: libnotify-bin
    state: present

# === Claude Code ===

- name: Check if Claude Code is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which claude
  register: claude_macos_check
  changed_when: false
  failed_when: false

- name: Install Claude Code (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - claude_macos_check.rc != 0
  community.general.homebrew_cask:
    name: claude-code
    state: present

- name: Check if Claude Code is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which claude
  register: claude_check
  changed_when: false
  failed_when: false

- name: Install Claude Code (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - claude_check.rc != 0
  ansible.builtin.shell: |
    curl -fsSL https://claude.ai/install.sh | bash
  args:
    creates: "{{ ansible_facts['env']['HOME'] }}/.claude/local/bin/claude"

# === OpenCode ===

- name: Check if OpenCode is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which opencode
  register: opencode_macos_check
  changed_when: false
  failed_when: false

- name: Tap anomalyco/tap for OpenCode (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - opencode_macos_check.rc != 0
  community.general.homebrew_tap:
    name: anomalyco/tap
    state: present

- name: Install OpenCode (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - opencode_macos_check.rc != 0
  community.general.homebrew:
    name: opencode
    state: present

- name: Check if OpenCode is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which opencode
  register: opencode_check
  changed_when: false
  failed_when: false

- name: Install OpenCode (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - opencode_check.rc != 0
  ansible.builtin.shell: |
    curl -fsSL https://opencode.ai/install | bash
  args:
    creates: "{{ ansible_facts['env']['HOME'] }}/.opencode/bin/opencode"

# === Cursor CLI ===
# Note: cursor-cli cask provides `cursor-agent` and `agent` binaries, not `cursor`

- name: Check if Cursor CLI is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which cursor-agent
  register: cursor_macos_check
  changed_when: false
  failed_when: false

- name: Install Cursor CLI (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - cursor_macos_check.rc != 0
  community.general.homebrew_cask:
    name: cursor-cli
    state: present
  ignore_errors: true  # Network errors shouldn't fail the playbook

- name: Check if Cursor CLI is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which cursor-agent
  register: cursor_check
  changed_when: false
  failed_when: false

- name: Install Cursor CLI (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - cursor_check.rc != 0
  ansible.builtin.shell: |
    curl -fsSL https://cursor.com/install | bash
  args:
    creates: "{{ ansible_facts['env']['HOME'] }}/.local/bin/cursor-agent"
  ignore_errors: true

# === GitHub Copilot CLI ===

- name: Check if npm is available
  ansible.builtin.command: which npm
  register: npm_check
  changed_when: false
  failed_when: false

- name: Check if GitHub Copilot CLI is installed
  when: npm_check.rc == 0
  ansible.builtin.command: which github-copilot-cli
  register: copilot_check
  changed_when: false
  failed_when: false

- name: Install GitHub Copilot CLI (npm)
  when:
    - npm_check.rc == 0
    - copilot_check.rc != 0
  community.general.npm:
    name: "@githubnext/github-copilot-cli"
    global: true
    state: present
  ignore_errors: true

# === OpenAI Codex CLI ===

- name: Check if OpenAI Codex CLI is installed via Homebrew cask (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: brew list --cask codex
  register: codex_macos_brew_check
  changed_when: false
  failed_when: false

- name: Install OpenAI Codex CLI (Homebrew cask - macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - codex_macos_brew_check.rc != 0
  community.general.homebrew_cask:
    name: codex
    state: present

- name: Get Homebrew prefix (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: brew --prefix
  register: codex_macos_brew_prefix
  changed_when: false

- name: Verify OpenAI Codex CLI binary is available from Homebrew path (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.stat:
    path: "{{ codex_macos_brew_prefix.stdout }}/bin/codex"
  register: codex_macos_bin_stat
  failed_when: not codex_macos_bin_stat.stat.exists

- name: Check if OpenAI Codex CLI is installed via npm (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - npm_check.rc == 0
  ansible.builtin.command: npm list -g --depth=0 @openai/codex
  register: codex_linux_npm_check
  changed_when: false
  failed_when: false

- name: Install OpenAI Codex CLI (npm - Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - npm_check.rc == 0
    - codex_linux_npm_check.rc != 0
  community.general.npm:
    name: "@openai/codex"
    global: true
    state: present

# === Gemini CLI ===

- name: Check if Gemini CLI is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which gemini
  register: gemini_macos_check
  changed_when: false
  failed_when: false

- name: Install Gemini CLI (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - gemini_macos_check.rc != 0
  community.general.homebrew:
    name: gemini-cli
    state: present

- name: Re-check Gemini CLI after Homebrew install (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - gemini_macos_check.rc != 0
  ansible.builtin.command: which gemini
  register: gemini_macos_postbrew_check
  changed_when: false
  failed_when: false

- name: Install Gemini CLI via npm fallback (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - gemini_macos_check.rc != 0
    - gemini_macos_postbrew_check.rc != 0
    - npm_check.rc == 0
  community.general.npm:
    name: "@google/gemini-cli"
    global: true
    state: present

- name: Check if Gemini CLI is installed (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - npm_check.rc == 0
  ansible.builtin.command: which gemini
  register: gemini_check
  changed_when: false
  failed_when: false

- name: Install Gemini CLI (npm - Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - npm_check.rc == 0
    - gemini_check.rc != 0
  community.general.npm:
    name: "@google/gemini-cli"
    global: true
    state: present
  ignore_errors: true

# === SpecStory ===

- name: Check if SpecStory is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which specstory
  register: specstory_macos_check
  changed_when: false
  failed_when: false

- name: Tap specstoryai/tap for SpecStory (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
  community.general.homebrew_tap:
    name: specstoryai/tap
    state: present

- name: Install SpecStory via Homebrew (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
  community.general.homebrew:
    name: specstory
    state: present
  ignore_errors: true

- name: Re-check if SpecStory is installed after Homebrew attempt (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
  ansible.builtin.command: which specstory
  register: specstory_macos_recheck
  changed_when: false
  failed_when: false

- name: Set SpecStory architecture for GitHub release (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
  ansible.builtin.set_fact:
    specstory_macos_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'arm64' else 'x86_64' }}"

- name: Get latest SpecStory release (macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
  ansible.builtin.uri:
    url: https://api.github.com/repos/specstoryai/getspecstory/releases/latest
    return_content: true
  register: specstory_macos_release

- name: Ensure ~/.local/bin exists (SpecStory macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
    - specstory_macos_release is defined
  ansible.builtin.file:
    path: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    state: directory
    mode: "0755"

- name: Download SpecStory from GitHub release (macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
    - specstory_macos_release is defined
  ansible.builtin.get_url:
    url: "https://github.com/specstoryai/getspecstory/releases/download/{{ specstory_macos_release.json.tag_name }}/SpecStoryCLI_Darwin_{{ specstory_macos_arch }}.zip"
    dest: /tmp/specstory-macos.zip
    mode: "0644"

- name: Extract SpecStory to ~/.local/bin (macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
    - specstory_macos_release is defined
  ansible.builtin.unarchive:
    src: /tmp/specstory-macos.zip
    dest: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    remote_src: true
    mode: "0755"

- name: Clean up SpecStory zip (macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
  ansible.builtin.file:
    path: /tmp/specstory-macos.zip
    state: absent

- name: Check if SpecStory is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which specstory
  register: specstory_check
  changed_when: false
  failed_when: false

- name: Get latest SpecStory release version (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
  ansible.builtin.uri:
    url: https://api.github.com/repos/specstoryai/getspecstory/releases/latest
    return_content: true
  register: specstory_release

- name: Set SpecStory architecture (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
  ansible.builtin.set_fact:
    specstory_linux_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'aarch64' else 'x86_64' }}"

- name: Download SpecStory from GitHub release (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
    - specstory_release is defined
  ansible.builtin.get_url:
    url: "https://github.com/specstoryai/getspecstory/releases/download/{{ specstory_release.json.tag_name }}/SpecStoryCLI_Linux_{{ specstory_linux_arch }}.tar.gz"
    dest: /tmp/specstory-linux.tar.gz
    mode: "0644"

- name: Ensure ~/.local/bin exists (SpecStory)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
    - specstory_release is defined
  ansible.builtin.file:
    path: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    state: directory
    mode: "0755"

- name: Extract SpecStory to ~/.local/bin (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
    - specstory_release is defined
  ansible.builtin.unarchive:
    src: /tmp/specstory-linux.tar.gz
    dest: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    remote_src: true
    mode: "0755"

- name: Clean up SpecStory tarball (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
  ansible.builtin.file:
    path: /tmp/specstory-linux.tar.gz
    state: absent

# === CodexBar ===

- name: Check if CodexBar is installed (macOS, ARM only)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - ansible_facts["architecture"] == "arm64"
  ansible.builtin.command: which codexbar
  register: codexbar_macos_check
  changed_when: false
  failed_when: false

- name: Tap steipete/tap for CodexBar (macOS, ARM only)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - ansible_facts["architecture"] == "arm64"
    - codexbar_macos_check.rc != 0
  community.general.homebrew_tap:
    name: steipete/tap
    state: present

- name: Install CodexBar (macOS, ARM only)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - ansible_facts["architecture"] == "arm64"
    - codexbar_macos_check.rc != 0
  community.general.homebrew_cask:
    name: codexbar
    state: present

- name: Check if CodexBar is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which codexbar
  register: codexbar_check
  changed_when: false
  failed_when: false

- name: Check if Homebrew (Linuxbrew) is available
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
  ansible.builtin.command: command -v brew
  register: codexbar_brew_check
  changed_when: false
  failed_when: false

- name: Install CodexBar via Linuxbrew (preferred)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc == 0
  block:
    - name: Tap steipete/tap for CodexBar (Linuxbrew)
      community.general.homebrew_tap:
        name: steipete/tap
        state: present

    - name: Install CodexBar (Linuxbrew)
      community.general.homebrew:
        name: codexbar
        state: present
  rescue:
    - name: Mark Linuxbrew install as failed
      ansible.builtin.set_fact:
        codexbar_brew_failed: true

- name: Ensure ~/.local/bin exists (CodexBar fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
  ansible.builtin.file:
    path: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    state: directory
    mode: '0755'

- name: Get latest CodexBar release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
  ansible.builtin.uri:
    url: https://api.github.com/repos/steipete/CodexBar/releases/latest
    return_content: true
  register: codexbar_release

- name: Compute CodexBar arch and tag (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_release is defined
  ansible.builtin.set_fact:
    codexbar_arch: "{{ ansible_facts['architecture'] }}"
    codexbar_tag: "{{ codexbar_release.json.tag_name.startswith('v') | ternary(codexbar_release.json.tag_name, 'v' ~ codexbar_release.json.tag_name) }}"

- name: Compute CodexBar release asset name (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_tag is defined
  ansible.builtin.set_fact:
    codexbar_asset: "CodexBarCLI-{{ codexbar_tag }}-linux-{{ codexbar_arch }}.tar.gz"

- name: Download CodexBar release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_asset is defined
  ansible.builtin.get_url:
    url: "https://github.com/steipete/CodexBar/releases/download/{{ codexbar_tag }}/{{ codexbar_asset }}"
    dest: /tmp/codexbar.tar.gz
    mode: '0644'

- name: Create temp directory for CodexBar extraction (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_asset is defined
  ansible.builtin.file:
    path: /tmp/codexbar
    state: directory
    mode: '0755'

- name: Extract CodexBar release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_asset is defined
  ansible.builtin.unarchive:
    src: /tmp/codexbar.tar.gz
    dest: /tmp/codexbar
    remote_src: true

- name: Find codexbar binary (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_asset is defined
  ansible.builtin.find:
    paths: /tmp/codexbar
    patterns: CodexBarCLI
    file_type: file
  register: codexbar_find

- name: Install CodexBar to ~/.local/bin (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_find.matched | default(0) | int > 0
  ansible.builtin.copy:
    src: "{{ codexbar_find.files[0].path }}"
    dest: "{{ ansible_facts['env']['HOME'] }}/.local/bin/codexbar"
    mode: '0755'
    remote_src: true

- name: Clean up CodexBar temp files (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - /tmp/codexbar.tar.gz
    - /tmp/codexbar

# === td ===

- name: Check if td is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which td
  register: td_macos_check
  changed_when: false
  failed_when: false

- name: Check whether installed td is Sidecar-compatible (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - td_macos_check.rc == 0
  ansible.builtin.shell: td --help 2>&1 | grep -Eq '\bsession\b'
  register: td_macos_compatible_check
  changed_when: false
  failed_when: false

- name: Remove conflicting td formula (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - td_macos_check.rc == 0
    - td_macos_compatible_check.rc != 0
  community.general.homebrew:
    name: td
    state: absent

- name: Tap marcus/tap for td (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - td_macos_check.rc != 0 or (td_macos_compatible_check.rc is defined and td_macos_compatible_check.rc != 0)
  community.general.homebrew_tap:
    name: marcus/tap
    state: present

- name: Install td (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - td_macos_check.rc != 0 or (td_macos_compatible_check.rc is defined and td_macos_compatible_check.rc != 0)
  community.general.homebrew:
    name: marcus/tap/td
    state: present

- name: Check if td is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which td
  register: td_check
  changed_when: false
  failed_when: false

- name: Check whether installed td is Sidecar-compatible (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc == 0
  ansible.builtin.shell: td --help 2>&1 | grep -Eq '\bsession\b'
  register: td_compatible_check
  changed_when: false
  failed_when: false

- name: Check if Homebrew (Linuxbrew) is available for td
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
  ansible.builtin.command: command -v brew
  register: td_brew_check
  changed_when: false
  failed_when: false

- name: Remove conflicting td formula (Linuxbrew)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc == 0
    - td_compatible_check.rc != 0
    - td_brew_check.rc == 0
  community.general.homebrew:
    name: td
    state: absent

- name: Install td via Linuxbrew (preferred)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_brew_check.rc == 0
  block:
    - name: Tap marcus/tap for td (Linuxbrew)
      community.general.homebrew_tap:
        name: marcus/tap
        state: present

    - name: Install td (Linuxbrew)
      community.general.homebrew:
        name: marcus/tap/td
        state: present
  rescue:
    - name: Continue with GitHub release fallback when td Linuxbrew install fails
      ansible.builtin.debug:
        msg: "td Linuxbrew installation failed, continuing with GitHub release fallback."

- name: Re-check if td is installed after Linuxbrew attempt
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
  ansible.builtin.command: which td
  register: td_recheck
  changed_when: false
  failed_when: false

- name: Ensure ~/.local/bin exists (td fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
  ansible.builtin.file:
    path: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    state: directory
    mode: "0755"

- name: Get latest td release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
  ansible.builtin.uri:
    url: https://api.github.com/repos/marcus/td/releases/latest
    return_content: true
  register: td_release

- name: Compute td release arch and version (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
    - td_release is defined
  ansible.builtin.set_fact:
    td_linux_arch: "{{ 'amd64' if ansible_facts['architecture'] in ['x86_64', 'amd64'] else 'arm64' if ansible_facts['architecture'] in ['aarch64', 'arm64'] else 'unsupported' }}"
    td_linux_version: "{{ td_release.json.tag_name | regex_replace('^v', '') }}"
    td_linux_tag: "{{ td_release.json.tag_name }}"

- name: Warn when td release fallback does not support current architecture
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
    - td_linux_arch == "unsupported"
  ansible.builtin.debug:
    msg: "td fallback skipped: unsupported architecture {{ ansible_facts['architecture'] }}."

- name: Download td release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
    - td_linux_arch != "unsupported"
  ansible.builtin.get_url:
    url: "https://github.com/marcus/td/releases/download/{{ td_linux_tag }}/td_{{ td_linux_version }}_linux_{{ td_linux_arch }}.tar.gz"
    dest: /tmp/td.tar.gz
    mode: "0644"

- name: Create temp directory for td extraction (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
    - td_linux_arch != "unsupported"
  ansible.builtin.file:
    path: /tmp/td
    state: directory
    mode: "0755"

- name: Extract td release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
    - td_linux_arch != "unsupported"
  ansible.builtin.unarchive:
    src: /tmp/td.tar.gz
    dest: /tmp/td
    remote_src: true

- name: Find td binary (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
    - td_linux_arch != "unsupported"
  ansible.builtin.find:
    paths: /tmp/td
    patterns: td
    file_type: file
  register: td_find

- name: Install td to ~/.local/bin (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
    - td_linux_arch != "unsupported"
    - td_find.matched | default(0) | int > 0
  ansible.builtin.copy:
    src: "{{ td_find.files[0].path }}"
    dest: "{{ ansible_facts['env']['HOME'] }}/.local/bin/td"
    mode: "0755"
    remote_src: true

- name: Clean up td temp files (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - td_check.rc != 0 or (td_compatible_check.rc is defined and td_compatible_check.rc != 0)
    - td_recheck.rc != 0
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - /tmp/td.tar.gz
    - /tmp/td

# === Sidecar ===

- name: Check if sidecar is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which sidecar
  register: sidecar_macos_check
  changed_when: false
  failed_when: false

- name: Tap marcus/tap for sidecar (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - sidecar_macos_check.rc != 0
  community.general.homebrew_tap:
    name: marcus/tap
    state: present

- name: Install sidecar (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - sidecar_macos_check.rc != 0
  community.general.homebrew:
    name: marcus/tap/sidecar
    state: present

- name: Check if sidecar is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which sidecar
  register: sidecar_check
  changed_when: false
  failed_when: false

- name: Check if Homebrew (Linuxbrew) is available for sidecar
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
  ansible.builtin.command: command -v brew
  register: sidecar_brew_check
  changed_when: false
  failed_when: false

- name: Install sidecar via Linuxbrew (preferred)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_brew_check.rc == 0
  block:
    - name: Tap marcus/tap for sidecar (Linuxbrew)
      community.general.homebrew_tap:
        name: marcus/tap
        state: present

    - name: Install sidecar (Linuxbrew)
      community.general.homebrew:
        name: marcus/tap/sidecar
        state: present
  rescue:
    - name: Continue with GitHub release fallback when sidecar Linuxbrew install fails
      ansible.builtin.debug:
        msg: "sidecar Linuxbrew installation failed, continuing with GitHub release fallback."

- name: Re-check if sidecar is installed after Linuxbrew attempt
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
  ansible.builtin.command: which sidecar
  register: sidecar_recheck
  changed_when: false
  failed_when: false

- name: Ensure ~/.local/bin exists (sidecar fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
  ansible.builtin.file:
    path: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    state: directory
    mode: "0755"

- name: Get latest sidecar release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
  ansible.builtin.uri:
    url: https://api.github.com/repos/marcus/sidecar/releases/latest
    return_content: true
  register: sidecar_release

- name: Compute sidecar release arch and version (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
    - sidecar_release is defined
  ansible.builtin.set_fact:
    sidecar_linux_arch: "{{ 'amd64' if ansible_facts['architecture'] in ['x86_64', 'amd64'] else 'arm64' if ansible_facts['architecture'] in ['aarch64', 'arm64'] else 'unsupported' }}"
    sidecar_linux_version: "{{ sidecar_release.json.tag_name | regex_replace('^v', '') }}"
    sidecar_linux_tag: "{{ sidecar_release.json.tag_name }}"

- name: Warn when sidecar release fallback does not support current architecture
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
    - sidecar_linux_arch == "unsupported"
  ansible.builtin.debug:
    msg: "sidecar fallback skipped: unsupported architecture {{ ansible_facts['architecture'] }}."

- name: Download sidecar release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
    - sidecar_linux_arch != "unsupported"
  ansible.builtin.get_url:
    url: "https://github.com/marcus/sidecar/releases/download/{{ sidecar_linux_tag }}/sidecar_{{ sidecar_linux_version }}_linux_{{ sidecar_linux_arch }}.tar.gz"
    dest: /tmp/sidecar.tar.gz
    mode: "0644"

- name: Create temp directory for sidecar extraction (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
    - sidecar_linux_arch != "unsupported"
  ansible.builtin.file:
    path: /tmp/sidecar
    state: directory
    mode: "0755"

- name: Extract sidecar release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
    - sidecar_linux_arch != "unsupported"
  ansible.builtin.unarchive:
    src: /tmp/sidecar.tar.gz
    dest: /tmp/sidecar
    remote_src: true

- name: Find sidecar binary (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
    - sidecar_linux_arch != "unsupported"
  ansible.builtin.find:
    paths: /tmp/sidecar
    patterns: sidecar
    file_type: file
  register: sidecar_find

- name: Install sidecar to ~/.local/bin (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
    - sidecar_linux_arch != "unsupported"
    - sidecar_find.matched | default(0) | int > 0
  ansible.builtin.copy:
    src: "{{ sidecar_find.files[0].path }}"
    dest: "{{ ansible_facts['env']['HOME'] }}/.local/bin/sidecar"
    mode: "0755"
    remote_src: true

- name: Clean up sidecar temp files (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - sidecar_check.rc != 0
    - sidecar_recheck.rc != 0
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - /tmp/sidecar.tar.gz
    - /tmp/sidecar

# === Specify CLI ===

- name: Check if uv is available
  ansible.builtin.command: which uv
  register: uv_check
  changed_when: false
  failed_when: false

- name: Check if Specify CLI is installed
  ansible.builtin.command: which specify
  register: specify_check
  changed_when: false
  failed_when: false

- name: Install Specify CLI via uv
  when:
    - uv_check.rc == 0
    - specify_check.rc != 0
  ansible.builtin.command: uv tool install specify-cli --from git+https://github.com/github/spec-kit.git
  args:
    creates: "{{ ansible_facts['env']['HOME'] }}/.local/bin/specify"

- name: Warn when uv is missing and Specify CLI is not installed
  when:
    - uv_check.rc != 0
    - specify_check.rc != 0
  ansible.builtin.debug:
    msg: "uv not found; skipping Specify CLI installation. Install uv first or install specify manually."

# === OpenChamber ===

- name: Check if OpenChamber is installed
  when: npm_check.rc == 0
  ansible.builtin.command: which openchamber
  register: openchamber_check
  changed_when: false
  failed_when: false

- name: Install OpenChamber (npm)
  when:
    - npm_check.rc == 0
    - openchamber_check.rc != 0
  community.general.npm:
    name: "@openchamber/web"
    global: true
    state: present
  ignore_errors: true

# === Happy ===

- name: Check if Happy is installed
  when: npm_check.rc == 0
  ansible.builtin.command: which happy
  register: happy_check
  changed_when: false
  failed_when: false

- name: Install Happy (npm)
  when:
    - npm_check.rc == 0
    - happy_check.rc != 0
  community.general.npm:
    name: happy-coder
    global: true
    state: present
  ignore_errors: true
