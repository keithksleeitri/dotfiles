---
# Coding Agents Installation
# Installs various AI coding assistants and companion tools
# All installations include idempotency checks to avoid slow reinstalls

# === Notification Tools (from claude_deps) ===

# macOS - terminal-notifier
- name: Install terminal-notifier (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  community.general.homebrew:
    name: terminal-notifier
    state: present

# Linux - libnotify-bin (provides notify-send)
- name: Install libnotify-bin (Debian/Ubuntu)
  when: ansible_facts["os_family"] == "Debian"
  become: true
  tags: [sudo]
  ansible.builtin.apt:
    name: libnotify-bin
    state: present

# === Claude Code ===

- name: Check if Claude Code is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which claude
  register: claude_macos_check
  changed_when: false
  failed_when: false

- name: Install Claude Code (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - claude_macos_check.rc != 0
  community.general.homebrew_cask:
    name: claude-code
    state: present

- name: Check if Claude Code is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which claude
  register: claude_check
  changed_when: false
  failed_when: false

- name: Install Claude Code (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - claude_check.rc != 0
  ansible.builtin.shell: |
    curl -fsSL https://claude.ai/install.sh | bash
  args:
    creates: "{{ ansible_facts['env']['HOME'] }}/.claude/local/bin/claude"

# === OpenCode ===

- name: Check if OpenCode is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which opencode
  register: opencode_macos_check
  changed_when: false
  failed_when: false

- name: Tap anomalyco/tap for OpenCode (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - opencode_macos_check.rc != 0
  community.general.homebrew_tap:
    name: anomalyco/tap
    state: present

- name: Install OpenCode (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - opencode_macos_check.rc != 0
  community.general.homebrew:
    name: opencode
    state: present

- name: Check if OpenCode is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which opencode
  register: opencode_check
  changed_when: false
  failed_when: false

- name: Install OpenCode (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - opencode_check.rc != 0
  ansible.builtin.shell: |
    curl -fsSL https://opencode.ai/install | bash
  args:
    creates: "{{ ansible_facts['env']['HOME'] }}/.opencode/bin/opencode"

# === Cursor CLI ===
# Note: cursor-cli cask provides `cursor-agent` and `agent` binaries, not `cursor`

- name: Check if Cursor CLI is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which cursor-agent
  register: cursor_macos_check
  changed_when: false
  failed_when: false

- name: Install Cursor CLI (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - cursor_macos_check.rc != 0
  community.general.homebrew_cask:
    name: cursor-cli
    state: present
  ignore_errors: true  # Network errors shouldn't fail the playbook

- name: Check if Cursor CLI is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which cursor-agent
  register: cursor_check
  changed_when: false
  failed_when: false

- name: Install Cursor CLI (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - cursor_check.rc != 0
  ansible.builtin.shell: |
    curl -fsSL https://cursor.com/install | bash
  args:
    creates: "{{ ansible_facts['env']['HOME'] }}/.local/bin/cursor-agent"
  ignore_errors: true

# === GitHub Copilot CLI ===

- name: Check if npm is available
  ansible.builtin.command: which npm
  register: npm_check
  changed_when: false
  failed_when: false

- name: Check if GitHub Copilot CLI is installed
  when: npm_check.rc == 0
  ansible.builtin.command: which github-copilot-cli
  register: copilot_check
  changed_when: false
  failed_when: false

- name: Install GitHub Copilot CLI (npm)
  when:
    - npm_check.rc == 0
    - copilot_check.rc != 0
  community.general.npm:
    name: "@githubnext/github-copilot-cli"
    global: true
    state: present
  ignore_errors: true

# === OpenAI Codex CLI ===

- name: Check if OpenAI Codex CLI is installed via Homebrew cask (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: brew list --cask codex
  register: codex_macos_brew_check
  changed_when: false
  failed_when: false

- name: Install OpenAI Codex CLI (Homebrew cask - macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - codex_macos_brew_check.rc != 0
  community.general.homebrew_cask:
    name: codex
    state: present

- name: Get Homebrew prefix (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: brew --prefix
  register: codex_macos_brew_prefix
  changed_when: false

- name: Verify OpenAI Codex CLI binary is available from Homebrew path (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.stat:
    path: "{{ codex_macos_brew_prefix.stdout }}/bin/codex"
  register: codex_macos_bin_stat
  failed_when: not codex_macos_bin_stat.stat.exists

- name: Check if OpenAI Codex CLI is installed via npm (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - npm_check.rc == 0
  ansible.builtin.command: npm list -g --depth=0 @openai/codex
  register: codex_linux_npm_check
  changed_when: false
  failed_when: false

- name: Install OpenAI Codex CLI (npm - Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - npm_check.rc == 0
    - codex_linux_npm_check.rc != 0
  community.general.npm:
    name: "@openai/codex"
    global: true
    state: present

# === Gemini CLI ===

- name: Check if Gemini CLI is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which gemini
  register: gemini_macos_check
  changed_when: false
  failed_when: false

- name: Install Gemini CLI (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - gemini_macos_check.rc != 0
  community.general.homebrew:
    name: gemini-cli
    state: present

- name: Re-check Gemini CLI after Homebrew install (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - gemini_macos_check.rc != 0
  ansible.builtin.command: which gemini
  register: gemini_macos_postbrew_check
  changed_when: false
  failed_when: false

- name: Install Gemini CLI via npm fallback (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - gemini_macos_check.rc != 0
    - gemini_macos_postbrew_check.rc != 0
    - npm_check.rc == 0
  community.general.npm:
    name: "@google/gemini-cli"
    global: true
    state: present

- name: Check if Gemini CLI is installed (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - npm_check.rc == 0
  ansible.builtin.command: which gemini
  register: gemini_check
  changed_when: false
  failed_when: false

- name: Install Gemini CLI (npm - Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - npm_check.rc == 0
    - gemini_check.rc != 0
  community.general.npm:
    name: "@google/gemini-cli"
    global: true
    state: present
  ignore_errors: true

# === SpecStory ===

- name: Check if SpecStory is installed (macOS)
  when: ansible_facts["os_family"] == "Darwin"
  ansible.builtin.command: which specstory
  register: specstory_macos_check
  changed_when: false
  failed_when: false

- name: Tap specstoryai/tap for SpecStory (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
  community.general.homebrew_tap:
    name: specstoryai/tap
    state: present

- name: Install SpecStory via Homebrew (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
  community.general.homebrew:
    name: specstory
    state: present
  ignore_errors: true

- name: Re-check if SpecStory is installed after Homebrew attempt (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
  ansible.builtin.command: which specstory
  register: specstory_macos_recheck
  changed_when: false
  failed_when: false

- name: Set SpecStory architecture for GitHub release (macOS)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
  ansible.builtin.set_fact:
    specstory_macos_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'arm64' else 'x86_64' }}"

- name: Get latest SpecStory release (macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
  ansible.builtin.uri:
    url: https://api.github.com/repos/specstoryai/getspecstory/releases/latest
    return_content: true
  register: specstory_macos_release

- name: Ensure ~/.local/bin exists (SpecStory macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
    - specstory_macos_release is defined
  ansible.builtin.file:
    path: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    state: directory
    mode: "0755"

- name: Download SpecStory from GitHub release (macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
    - specstory_macos_release is defined
  ansible.builtin.get_url:
    url: "https://github.com/specstoryai/getspecstory/releases/download/{{ specstory_macos_release.json.tag_name }}/SpecStoryCLI_Darwin_{{ specstory_macos_arch }}.zip"
    dest: /tmp/specstory-macos.zip
    mode: "0644"

- name: Extract SpecStory to ~/.local/bin (macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
    - specstory_macos_release is defined
  ansible.builtin.unarchive:
    src: /tmp/specstory-macos.zip
    dest: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    remote_src: true
    mode: "0755"

- name: Clean up SpecStory zip (macOS fallback)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - specstory_macos_check.rc != 0
    - specstory_macos_recheck.rc != 0
  ansible.builtin.file:
    path: /tmp/specstory-macos.zip
    state: absent

- name: Check if SpecStory is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which specstory
  register: specstory_check
  changed_when: false
  failed_when: false

- name: Get latest SpecStory release version (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
  ansible.builtin.uri:
    url: https://api.github.com/repos/specstoryai/getspecstory/releases/latest
    return_content: true
  register: specstory_release

- name: Set SpecStory architecture (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
  ansible.builtin.set_fact:
    specstory_linux_arch: "{{ 'arm64' if ansible_facts['architecture'] == 'aarch64' else 'x86_64' }}"

- name: Download SpecStory from GitHub release (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
    - specstory_release is defined
  ansible.builtin.get_url:
    url: "https://github.com/specstoryai/getspecstory/releases/download/{{ specstory_release.json.tag_name }}/SpecStoryCLI_Linux_{{ specstory_linux_arch }}.tar.gz"
    dest: /tmp/specstory-linux.tar.gz
    mode: "0644"

- name: Ensure ~/.local/bin exists (SpecStory)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
    - specstory_release is defined
  ansible.builtin.file:
    path: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    state: directory
    mode: "0755"

- name: Extract SpecStory to ~/.local/bin (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
    - specstory_release is defined
  ansible.builtin.unarchive:
    src: /tmp/specstory-linux.tar.gz
    dest: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    remote_src: true
    mode: "0755"

- name: Clean up SpecStory tarball (Linux)
  when:
    - ansible_facts["os_family"] == "Debian"
    - specstory_check.rc != 0
  ansible.builtin.file:
    path: /tmp/specstory-linux.tar.gz
    state: absent

# === CodexBar ===

- name: Check if CodexBar is installed (macOS, ARM only)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - ansible_facts["architecture"] == "arm64"
  ansible.builtin.command: which codexbar
  register: codexbar_macos_check
  changed_when: false
  failed_when: false

- name: Tap steipete/tap for CodexBar (macOS, ARM only)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - ansible_facts["architecture"] == "arm64"
    - codexbar_macos_check.rc != 0
  community.general.homebrew_tap:
    name: steipete/tap
    state: present

- name: Install CodexBar (macOS, ARM only)
  when:
    - ansible_facts["os_family"] == "Darwin"
    - ansible_facts["architecture"] == "arm64"
    - codexbar_macos_check.rc != 0
  community.general.homebrew_cask:
    name: codexbar
    state: present

- name: Check if CodexBar is installed (Linux)
  when: ansible_facts["os_family"] == "Debian"
  ansible.builtin.command: which codexbar
  register: codexbar_check
  changed_when: false
  failed_when: false

- name: Check if Homebrew (Linuxbrew) is available
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
  ansible.builtin.command: command -v brew
  register: codexbar_brew_check
  changed_when: false
  failed_when: false

- name: Install CodexBar via Linuxbrew (preferred)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc == 0
  block:
    - name: Tap steipete/tap for CodexBar (Linuxbrew)
      community.general.homebrew_tap:
        name: steipete/tap
        state: present

    - name: Install CodexBar (Linuxbrew)
      community.general.homebrew:
        name: codexbar
        state: present
  rescue:
    - name: Mark Linuxbrew install as failed
      ansible.builtin.set_fact:
        codexbar_brew_failed: true

- name: Ensure ~/.local/bin exists (CodexBar fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
  ansible.builtin.file:
    path: "{{ ansible_facts['env']['HOME'] }}/.local/bin"
    state: directory
    mode: '0755'

- name: Get latest CodexBar release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
  ansible.builtin.uri:
    url: https://api.github.com/repos/steipete/CodexBar/releases/latest
    return_content: true
  register: codexbar_release

- name: Compute CodexBar arch and tag (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_release is defined
  ansible.builtin.set_fact:
    codexbar_arch: "{{ ansible_facts['architecture'] }}"
    codexbar_tag: "{{ codexbar_release.json.tag_name.startswith('v') | ternary(codexbar_release.json.tag_name, 'v' ~ codexbar_release.json.tag_name) }}"

- name: Compute CodexBar release asset name (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_tag is defined
  ansible.builtin.set_fact:
    codexbar_asset: "CodexBarCLI-{{ codexbar_tag }}-linux-{{ codexbar_arch }}.tar.gz"

- name: Download CodexBar release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_asset is defined
  ansible.builtin.get_url:
    url: "https://github.com/steipete/CodexBar/releases/download/{{ codexbar_tag }}/{{ codexbar_asset }}"
    dest: /tmp/codexbar.tar.gz
    mode: '0644'

- name: Create temp directory for CodexBar extraction (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_asset is defined
  ansible.builtin.file:
    path: /tmp/codexbar
    state: directory
    mode: '0755'

- name: Extract CodexBar release (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_asset is defined
  ansible.builtin.unarchive:
    src: /tmp/codexbar.tar.gz
    dest: /tmp/codexbar
    remote_src: true

- name: Find codexbar binary (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_asset is defined
  ansible.builtin.find:
    paths: /tmp/codexbar
    patterns: CodexBarCLI
    file_type: file
  register: codexbar_find

- name: Install CodexBar to ~/.local/bin (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
    - codexbar_find.matched | default(0) | int > 0
  ansible.builtin.copy:
    src: "{{ codexbar_find.files[0].path }}"
    dest: "{{ ansible_facts['env']['HOME'] }}/.local/bin/codexbar"
    mode: '0755'
    remote_src: true

- name: Clean up CodexBar temp files (Linux fallback)
  when:
    - ansible_facts["os_family"] == "Debian"
    - codexbar_check.rc != 0
    - codexbar_brew_check.rc != 0 or (codexbar_brew_failed | default(false))
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - /tmp/codexbar.tar.gz
    - /tmp/codexbar

# === Happy ===

- name: Check if Happy is installed
  when: npm_check.rc == 0
  ansible.builtin.command: which happy
  register: happy_check
  changed_when: false
  failed_when: false

- name: Install Happy (npm)
  when:
    - npm_check.rc == 0
    - happy_check.rc != 0
  community.general.npm:
    name: happy-coder
    global: true
    state: present
  ignore_errors: true
